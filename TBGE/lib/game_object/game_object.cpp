#include "include\game_object\game_object.h"

#include "SHL\exceptions\not_implemented_exception.h"

namespace tbge {
/**
 * @brief Constructs an empty GameObject with default values.@n
 *        @ref name_ is set to @ref class_name_ + "_" + @ref id_.@n
 *        All other data members are left empty.
 */
GameObject::GameObject()
    : GameObject("", (GameObject*)nullptr, std::vector<GameObject*>()) {}

/**
 * @brief Copy constructor
 * @param @a game_object A reference to the GameObject to copy from.
 */
GameObject::GameObject(GameObject& game_object) {
  this->id_ = game_object.get_id();
  this->name_ = game_object.get_name();
  this->parent_ = game_object.get_parent();
  this->children_ = game_object.get_children();
}

/**
 * @brief Same as default constructor, but sets a name
 * @param @a name name to be set
 */
GameObject::GameObject(std::string name)
    : GameObject(name, (GameObject*)nullptr, std::vector<GameObject*>()) {}

/**
 * @brief The full constructor for GameObject
 * @param @a name The name of the object, used for accessing it from other
 *        objects. If set to "" it will be generated by this format: @ref
 *        class_name_ + "_" + @ref id_ @n.
 * @param @a parent Pointer to the parent GameObject, if any.
 * @param @a children A list of pointers to the child GameObjects if any.
 */
GameObject::GameObject(std::string name, GameObject* parent,
                       std::vector<GameObject*> children) {
  AssignId();
  if (name != "") {
    set_name(name);
  } else {
    AssignDefaultName();
  }

  set_parent(parent);
  set_children(children);
}

/**
 * @details Getter for the full name of the GameObject.@n
 *          The full name of a game object is its name_ preceded by its parent's
 *          full_name (recursively) seperated with a "."
 * @return The full name of the GameObject
 */
std::string GameObject::get_full_name() {
  if (this->parent_) {
    return this->parent_->get_full_name() + "." + this->name_;
  }
  return this->name_;
}

/**
 * @details Setter for the name of the GameObject
 * @param @a name The new name to be set
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::set_name(std::string name) {
  name_ = name;
  return *this;
}

/**
 * @details Setter for the parent of the GameObject
 *          First unregisters itself from its current parent, if it has any.
 *          Then registers itself with the given GameObject
 * @param @a parent The new parent to be set
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::set_parent(GameObject* parent) {
  if (parent) {
    parent_ = parent;
    parent->add_child(this);
  }
  return *this;
}

/**
 * @details Setter for the children-list of the GameObject
 * @param @a children The new list of children to be set
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::set_children(std::vector<GameObject*> children) {
  children_.clear();
  for (GameObject* child : children) {
    add_child(child);
  }
  return *this;
}

/**
 * @brief Adds a child to the current GameObject's children_ list, also
 *        unregisters the child from its previous parent
 * @param @a child The child to be added to children_
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::add_child(GameObject* child) {
  if (FindIndexOfChild(child) != -1) {
    return *this;
  }
  children_.push_back(child);
  child->set_parent(this);
  return *this;
}

/**
 * @brief Adds a vector of GameObject pointers to the current GameObject's list
 *        of children_
 * @param @a children the vector to be added to children_
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::add_children(std::vector<GameObject*> children) {
  for (GameObject* child : children) {
    add_child(child);
  }
  return *this;
}

/**
 * @brief Removes the current parent, and unregisters the current GameObject
 *        from the old parents children_ list
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::remove_parent() {
  if (parent_) {
    parent_->remove_child(this);
    parent_ = nullptr;
  }
  return *this;
}

/**
 * @brief Removes the given GameObject from the children_ list of the current
 *        GameObject, and unregisters the current GameObject as the given
 *        GameObject's parent
 * @param @a child A pointer to the child to be removed
 * @return A reference to @a this to enable method-chaining
 */
GameObject& GameObject::remove_child(GameObject* child) {
  if (FindIndexOfChild(child) != -1) {
    children_.erase(children_.begin() + FindIndexOfChild(child));
    child->remove_parent();
  }
  return *this;
}

/**
 * @brief Checks if the current GameObject has the given GameObject as a child.
 * @param @a child The GameObject to be checked for
 * @return The index of the child if it is found, otherwise returns -1
 */
int GameObject::FindIndexOfChild(GameObject* child) {
  for (int i = 0; i < children_.size(); i++) {
    if (child == children_[i]) {
      return i;
    }
  }
  return -1;
}

/**
 * @brief Assigns a unique id to every GameObject, to be run in all
 * constructors.
 * @return @a This to enable method chaining.
 */
GameObject& GameObject::AssignId() {
  static int id_counter;
  this->id_ = id_counter;
  id_counter++;
  return *this;
}

/**
 * @brief Assigns a deafault name to the object, to be used in constructors
 *        without properties for name.
 * @return @a This to enable method chaining.
 */
GameObject& GameObject::AssignDefaultName() {
  name_ = class_name_ + "_" + std::to_string(id_);
  return *this;
}
}  // namespace tbge
